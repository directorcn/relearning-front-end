

# Data Types

## 原始数据类型

### Undefined

`Undefined` 类型只有一个值，就是 `undefiend`，表示“未定义”。任何变量在声明之后，赋值前都是 `Undefied` 类型，值也是`undefined`。在 `JavaScript` 中 `undefined` 并非关键字，而是一个全局变量，值为 `undefiend`，为了避免无意中的篡改，建议采用 `void 0` 来代替。全局作用域的 `undefined` 变量不能被修改，局部作用域的`undefined` 变量可以被修改。 

```js
{
    let undefined = 100;
    console.log(undefined); // 100
}
```



### Null

`Null` 类型只有一个值，就是 `null` 本身。表示“空”。

### Boolean

只有两个逻辑值 `true` 和 `false`。

### String

字符串类型通常用于表示正在运行的`JavaScript` 程序中的文本数据，最大长度 ![img](https://latex.codecogs.com/svg.latex?2^{53}%20-%201)，但这并不是字符串的最大字符数，字符串的长度是字符串中元素的数量，每个元素可以视为单个`UTF-16` 代码单元，所以字符串的最大程度与字符串的编码方式强相关。

#### String Grammer

```js
"abc"
'abc'
`abc`

// template 词法解析 1.`${  2. }`
var name = 'template';

`hello,${
name
}`
```



### Symbol

所有非字符串值的集合，其值是唯一且不可变的。

### Number

`Number` 类型有 18437736874454810627(即 ![img](https://latex.codecogs.com/svg.latex?2^{64}-2^{53}+3)) 个值，`NaN`、`Infinity`、`-Infinity` 都是 `Number` 类型。

* **IEEE 754 Double Float**

  * Sign （1 bit）*符号*， `0` 代表数值为正，`1` 代表数值为负。

  * Exponent（11 bit）*指数*

  * Fraction（52 bit）*有效数字* ，大于等于1，小于2。

  在二进制，第一个有效数字必定是“1”，因此这个“1”并不会存储。

  二进制浮点数 ![img](https://latex.codecogs.com/svg.latex?V%20=%20(-1)^S%20%20*%202^E*%20M)

  **高位放在低地址就是大端法，低位放在低地址就是小端法**

<div><pre>sign       exponent                              fraction
├─┼─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬────────────┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┤
├─┼───────────────────┼─┼──────────────────────────────────────────────────────┼─┤
 63                    53                                                       0  </pre></div>

跑下面这片代码你可以看到浮点数在内存中的存储序列。

```js
function convertDouble(val) {
    const bits = new Array(64).fill(0);
    const bytes = new Uint8Array(8);
    const memory = new Float64Array(bytes.buffer);
    memory[0] = (val);
    for (let i = 0; i < 8; i ++) {
        let byte = bytes[i];
        for (let j = 0; j < 8; j ++) {
            bits[(8 - i) * 8 - j - 1] = byte & 1;
            byte = byte >> 1;
        }
    }
    return bits.join('');
}
```



#### Number Grammer

* `DecimalLiteral`
  * 0
  * 0.
  * .2
  * 1E3
* `BinaryIntergerLiteral`
  * 0b111
* `OctalIntergerLiteral`
  * 0o10
* `HexIntergerLiteral`
  * 0xFF

```js
2 .toString(2) // '10'
2.toString(2) // SyntaxError 2.是一个合法的 token -> DecimalLiteral
```



### BigInt

`BigInt` 是一种数字类型的数据，它可以表示任意精度格式的整数。



#### Q：undefined 和 null 的区别？

**A：**

> `undefined` 是 `Undefined` 类型，表示“未定义”，`null` 是 `Null` 类型，表示“空”；
>
> `null` 是 `JavaScript` 关键字，不可以被赋值，`undefined` 是一个全局变量，可以被赋值，在非全局作用域可以任意修改它的值；
>
> `typeof` 的结果不同，`typeof undefined === "undefined"`，`typeof null === "object"`，这是 `JavaScript` 的设计失误，是一个历史遗留问题。所以 `null` 也是原型链的顶端；
>
> `null` 隐式类型转换为 `0`，`undefined` 隐式类型转换为 `NaN`。

```js
100 + null // 100
100 + undefined // NaN
```



#### Q：0.1 + 0.2 != 0.3

**A：**

`JavaScript` 采用 `IEEE 754` 双精度浮点型标准，计算机中存储的都是二进制，而 `0.1`，`0.2` 转成二进制都是无限循环小数，由于`IEEE 754 Double Float` 标准最多只能存储 64 bit，所以会对超出的部分进行取舍，造成精度丢失。

<div><pre>
                                    0.1    指数位(整数位)
                                   ×  2
                                ──────────────
                                    0.2		0
                                   ×  2
                                ──────────────
                                    0.4		0    --👇--
                                   ×  2
                                ──────────────
                                    0.8		0
                                   ×  2
                                ──────────────
                                    0.6		1
                                   ×  2
                                ──────────────
                                    0.2		1
                                   ×  2
                                ──────────────
                                    0.4		0    --👆--
                                              (0011 循环)</pre></div>

```js
// 00111111 10111001 10011001 10011001 10011001 10011001 10011001 10011010

/*
 * sign  exponent                        fraction
 *   0 01111111011 1001100110011001100110011001100110011001100110011010
 *   +1 * 2^-4 * 1.1001100110011001100110011001100110011001100110011010
 * 为了处理负指数的情况，实际的指数值按要求需要加上一个偏置（Bias）值作为保存在指数段中的值。
 *（单精度是 127，双精度是 1023）
 *   -4 = 0b01111111011 - 1023
*/
0.1 = (-1)^0 * 2^-4 * 1.10011(0011)

// 如何解决精度丢失问题
parseFloat((0.1 + 0.2).toFixed(10)) // 0.3
```



## 引用数据类型

### Object

`Object`对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 `key-value` 结构，`key` 可以是字符串或者 `Symbol` 类型。



**原始数据类型存储在栈（stack）内存，引用数据类型存储在堆（heap）内存，栈内存存储的是堆地址。原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。**

<div><pre>
┌────────────────────────┐                       ┌────────────────────────┐
│  variable environment  │                       │  地址   |      值       │
├────────┬───────────────┤                       ├────────┼───────────────┤
│变量名   |     变量值     │                       │ ....   │               │
├────────┼───────────────┤                       ├────────┼───────────────┤
│ foo    │      'foo'    │                       │ 1002   │               │
├────────┼───────────────┤                       ├────────┼───────────────┤
│ bar    │      1003     │──────────────────────>│ 1003   │ {name: "bar"} │
└────────┴───────────────┘                       └────────┴───────────────┘
        call stack                                          heap</pre></div>
#### Q：为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？

> `JavaScript` 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。



#### Q：垃圾回收

> 栈内存回收：移动栈指针
>
> 堆内存回收：
>
> 从 GC Roots 对象出发，遍历 GC Roots 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据。V8 会有专门的垃圾回收器来回收这些垃圾数据。
>
> V8 依据代际假说，将堆内存划分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。为了提升垃圾回收的效率，V8 设置了两个垃圾回收器，主垃圾回收器和副垃圾回收器。主垃圾回收器负责收集老生代中的垃圾数据，副垃圾回收器负责收集新生代中的垃圾数据。
>
> 副垃圾回收器采用了 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。主垃圾回收器回收器主要负责老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程。




## 延伸

* [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754)
* [双精度浮点数](https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8)
* [二进制转换工具](http://www.binaryconvert.com/)



