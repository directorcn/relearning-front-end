# 继承

`JavaScript` 每个对象都有一个`prototype` 属性(原型)，该属性指向了原型对象，查找属性的时候，`JavaScript` 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。若找不到，就是 `undefined`。



## 原型链继承

基本思想：重写子构造函数的原型对象



```js
function Parent() {
    this.firstName = 'Jack';
    this.lastName = 'Ma';
    this.fruits = ['apple', 'banana'];
}

function Child() {
    this.firstName = 'Hony';
}

// 父构造函数的实例赋值给子构造函数的原型
Child.prototype = new Parent;
var child = new Child;
child.lastName // Ma
child.firstName // Hony

child.fruits.push('orange');
var c = new Child;
c.fruits // ['apple', 'banana', 'orange']
```

问题：

1. 子构造函数的所有实例共享**引用类型**的属性

2. 创建子构造函数时，无法向父构造函数传参



## 借用构造函数

基本思想：在子构造函数的内部调用父构造函数



```js
function Parent(firstName) {
    this.firstName = firstName;
    this.lastName = 'Ma';
    this.fruits = ['apple'];
}

function Child(firstName, age) {
    Parent.call(this, firstName);
    this.age = age;
}

var child = new Child('Hony', 18);

child.lastName // Ma
child.age // 18
child.fruits.push('orange'); // ['apple', 'orange']

var c = new Child('Jone', 18);
c.fruits // ['apple']
```

问题：

1. 方法都得在构造函数中定义，没有复用的能力

2. 父构造函数原型上的属性方法，子构造函数不可见



## 组合继承

基本思路：使用原型链实现对原型属性方法的继承，通过借用构造函数来实现对象实例属性的继承



```js
function Parent(firstName) {
    this.firstName = firstName;
    this.lastName = 'Ma';
    this.fruits = ['apple'];
}

Parent.prototype.sayName = function() {
    return this.firstName;
}

Child.prototype = new Parent;

function Child(firstName, age) {
    Parent.call(this, firstName);
    this.age = age;
}

var child = new Child('Hony', 18);
child.sayName(); // Hony
child.fruits.push('orange');
child.fruits // ['apple', 'orange']

var c = new Child('Jone', 18);
c.fruits // ['apple']
```

既可以在原型上定义方法实现函数复用，又能保证每个实例都有自己的属性



## 原型式继承

基本思路：借助原型可以基于已有的对象创建新的对象



```js
function inhert(o) {
    function F() {}
    F.prototype = o;
    return F();
}
```

```js
// Object.create(ptototype[, propertiesObject])
var parent = {
    firstName: 'Jack',
    lastName: 'Ma',
    fruits: ['apple']
};
var child = Object.create(parent, {
    firstName: { 
        writable:true,
        configurable:true,
        value: "Hony" 
    }
});
child.firstName // Hony
```

问题：包含引用类型的属性会被共享



## 寄生式继承

```js
function inhert(o) {
    function F() {}
    F.prototype = o;
    var clone = new F;
    clone.sayName = function() {
        return this.firstName;
    }
    return clone;
}
```

在原生式继承的基础上，给创建的对象上挂方法（或引用类型属性），



## 圣杯模式

```js
Parent.pototype.lastName = 'Ma';
function Parent() {}
function Child() {}

function inhert(Target, Origin) {
    // 引入中键构造函数
    function F() {}
    // 子构造函数的原型指向中间构造函数的原型
    F.prototype = Origin.prototype;
    // 中间构造函数的实例指向父构造函数
    Target.prototype = new F;
}

inhert(Parent, Child);
var child = new Child;
```



## `class`

```js
class Parent {
    constructor() {
        this.firstName = 'Jack';
        this.lastName = 'Ma';
        this.fruits = ['apple'];
    }
    sayName() {
        return this.firstName;
    }
}

class Child extends Parent {
    constructor() {
    	super();
        this.firstName = 'Hony';
    }
}
```



### Q：`ES5` 继承与 `ES6` 继承的区别？ 

**A：**

* `ES5` ：先创建子构造函数的实例，再调父构造函数的 `call` 方法，将父构造函数的属性方法添加到子构造函数

* `ES6` ：先创建父类的实例对象，再在子类的构造函数调 `super` 方法改变 `this`（先调 `super` 才能访问 `this`）


