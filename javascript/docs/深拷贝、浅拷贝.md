# 深拷贝、浅拷贝

```js
let o = { x: 1 };
let p = o;
p.y = 2, p.x = 0;
o.x // 0
o.y // 2
```

想必这个例子大家都非常熟悉了，引用类型的赋值共享栈内的内存地址，所以，当我们修改 `p`  的时候，`o` 也跟着变了，很显然，这并不是我们所期望的结果。

### 浅拷贝

`Object.assign`，`...` 运算符都是浅拷贝

```js
let o = { x: 1 };
let p = Object.assign({}, o);
p.x // 1

p.x = 100, p.y = 2;
o.x // 1
o.y // undefined
```

```js
let o = { x: 1 };
let p = { ...o };

p.x = 100, p.y = 2;
o.x // 1
o.y // undefined
```

**浅拷贝只能拷贝一层，也就是说如果属性是引用类型，拷贝的还是地址。**

```js
let o = {
    x: 1,
    y: 2,
    z: {
        m: 0
    }
};
let p = { ...o };

p.z.m = 100;
o.z.m // 100
```



### 深拷贝

新开辟了栈内存，两个对象指向不同的地址。

* 递归

```js
function deepCopy(obj){
    if(obj && typeof obj === 'object'){
        let clone = Array.isArray(obj) ? [] : {};
        for(let key in obj){
            if(obj.hasOwnProperty(key)){
                clone[key] = deepCopy(obj[key]);
            }
        }
        return clone;
    }
    return obj;
}
```

循环引用时，死循环导致栈溢出。



* 深拷贝也可以通过 `JSON.parse(JSON.stringify(object))` 来解决。

```js
let o = {
    x: 1,
    y: 2,
    z: {
        m: 0
    }
};
let p = JSON.parse(JSON.stringify(o));

p.z.m = 100;
o.z.m // 0
```

但是这个方法也有局限性：

* 会忽略 `undefined`

* 会忽略 `symbol`

* 不能序列化函数

* 不能解决循环引用



### Q：如何解决循环引用？

**A：**

```js
function deepCopy(obj, map = new Map) {
    if (typeof obj === 'object') {
        let clone = Array.isArray(obj) ? [] : {};
        // 如果对象已经被记录，直接返回
        if(map.has(obj)) {
            return map.get(obj);
        }
        map.set(obj, clone);
        for(var i in obj){
            clone[i] = deepCopy(obj[i], map);
        }
        return map.get(obj);
    }
    return obj;
}
```


