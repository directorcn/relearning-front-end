# 防抖节流

* 防抖

> 在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，重新计时。

```js
function debounce(fn, delay, immediate) {
    let timer = null, result = void 0;
    let debounced = function() {
        const _this = this;
        const args = arguments;
        if (timer)
            clearTimeout(timer);
        if (immediate) {
            let callNow = !timer;
            timer = setTimeout(function() {
                timer = null;
            }, delay);
            if (callNow)
                result = fn.apply(_this, args);
        } else {
            timer = setTimeout(function() {
                fn.apply(_this, args);
            }, delay);
        }
        return result;
    }
    debounced.cancel = function() {
        clearTimeout(timer);
        timer = null;
    }
    return debounced;
}
```



* 节流

> 单位时间内，只有一次触发事件的回调可执行，如果同一单位时间内触发 n 次，只能有一次生效。

使用时间戳：第一次事件会立即执行，停止触发后不会再执行事件

使用定时器：第一次事件会在 `n` 秒后执行，停止触发后还会再执行一次事件



```js
function throttle(fn, delay) {
    let previous = 0,
        timer = null,
        _this,
        args;
    let later = () => {
        previous = Date.now();
        timer = null;
        fn.apply(_this, args);
    };
    let throttled = function() {
        let now = Date.now();
        // 下次触发 fn 剩余的时间
        let remaining = delay - (now - previous);
        _this = this;
        args = arguments;
        // 没有剩余时间或修改了系统时间
        if (remaining <= 0 || remaining > delay) {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            previous = now;
            fn.apply(_this, args);
        } else if (!timer) {
            timer = setTimeout(later, remaining);
        }
    }
	return throttled;
}
```



防抖的本质是将多次执行变为最后一次执行，节流的本质是将多次执行变成每隔一段时间只执行一次。


